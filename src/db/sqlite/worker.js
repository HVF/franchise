import SQL from 'sql.js'
import XLSX from 'xlsx'



// Generated by CoffeeScript 1.7.1
var createDb, db;

if (typeof importScripts === 'function') {
  db = null;
  createDb = function(data) {
    if (db != null) {
      db.close();
    }
    return db = new SQL.Database(data);
  };
  self.onmessage = function(event) {
    var buff, callback, data, done, err;
    data = event['data'];
    switch (data != null ? data['action'] : void 0) {
      case 'open':
        buff = data['buffer'];
        var array, isSQLite;
        if(buff){
          array = new Uint8Array(buff);
          isSQLite = 'SQLite format 3'.split('')
            .every((k, i) => k.charCodeAt(0) == array[i]) &&
            array[15] == 0;
        }
        createDb((isSQLite ? array : void 0));
        if(buff && !isSQLite){
          var str = Uint8ArrayToString(array);

          var json_list, errors = [];
          if(str.match(/\s*\[/)){
            // JSON list
            try {
              json_list = JSON.parse(str)
            } catch (err) { errors.push(err) }

          }else if(str.match(/\s*\{/)){
            // JSONM
            var tmp_list = []
            str.split('\n').forEach(k => {
              try {
                tmp_list.push(JSON.parse(k))
              } catch (err) { errors.push(err) }
            })
            if(tmp_list.length > 0){
              json_list = tmp_list;
            }
          }
          if(json_list){
            var fields = {}
            json_list.forEach(k => Object.keys(k).forEach(j => fields[j] = true));
            var keys = Object.keys(fields);

            function run_stmt(x){
              console.log(x)
              db.exec(x)
            }

            function escapeIdent(x){
              return '"' + (x + '').replace(/"/g, '""') + '"'
            }
            function escapeStr(x){
              return "'" + (x + '').replace(/'/g, "''") + "'"
            }
            var sname = data['sname'] || "Sheet1"
            run_stmt('DROP TABLE IF EXISTS ' + escapeIdent(sname) + ';')
            run_stmt('CREATE TABLE ' + escapeIdent(sname) + ' (' + keys.map(k => `${escapeIdent(k)} TEXT`).join(', ') + ');');

            json_list.forEach(k => {
              run_stmt("INSERT INTO " +escapeIdent(sname) + " (" + Object.keys(k).map(escapeIdent).join(", ") + ") VALUES (" + Object.values(k).map(escapeStr).join(",") + ");");
            })

          }else{
            var not_sql = false;
            try {
              db.exec(str);
            } catch (err) {
              console.log("Failed attempt to interpet as SQL: " + err);
              not_sql = true;
            }

            if(not_sql){
              var wb = XLSX.read(str, { type: 'binary', cellDates:true });
              wb.SheetNames.forEach(function(s) {
                var sname = wb.SheetNames.length > 1
                  ? s
                  : (data['sname'] || s)
                prepforsexql(wb.Sheets[s], sname, db);
              });
            }

          }
        }

        return postMessage({
          'id': data['id'],
          'ready': true
        });
      case 'exec':
        if (db === null) {
          createDb();
        }
        if (!data['sql']) {
          throw 'exec: Missing query string';
        }
        return postMessage({
          'id': data['id'],
          'results': db.exec(data['sql'])
        });
      case 'each':
        if (db === null) {
          createDb();
        }
        callback = function(row) {
          return postMessage({
            'id': data['id'],
            'row': row,
            'finished': false
          });
        };
        done = function() {
          return postMessage({
            'id': data['id'],
            'finished': true
          });
        };
        return db.each(data['sql'], data['params'], callback, done);
      case 'export':
        buff = db["export"]().buffer;
        try {
          return postMessage({
            'id': data['id'],
            'buffer': buff
          }, [buff]);
        } catch (_error) {
          err = _error;
          return postMessage({
            'id': data['id'],
            'buffer': buff
          });
        }
        break;
      case 'close':
        return db != null ? db.close() : void 0;
      default:
        throw new 'Invalid action : ' + (data != null ? data['action'] : void 0);
    }
  };
}

function arrayBufferToString(data) {
  var o = "", l = 0, w = 10240;
  for(; l<data.byteLength/w; ++l) o+=String.fromCharCode.apply(null,new Uint8Array(data.slice(l*w,l*w+w)));
  o+=String.fromCharCode.apply(null, new Uint8Array(data.slice(l*w)));
  return o;
}


function Uint8ArrayToString(data){
  var arr = new Array();
  for(var i = 0; i != data.length; ++i) arr[i] = String.fromCharCode(data[i]);
  return arr.join("");
}


// based on sheetjs.com/sexql/

function log_and_exec(db, query) {
  console.log(query);
  try { db.exec(query); } catch(e) { console.error(e); }
}
function prepforsexql(ws, sname, db) {
  /* Get sheet range */
  if(!ws || !ws['!ref']) return;
  var range = XLSX.utils.decode_range(ws['!ref']);
  if(!range || !range.s || !range.e || range.s > range.e) return;
  var R = range.s.r, C = range.s.c;

  /* Generate headers */
  var names = new Array(range.e.c-range.s.c+1);
  for(C = range.s.c; C<= range.e.c; ++C){
    var addr = XLSX.utils.encode_cell({c:C,r:R});
    names[C-range.s.c] = ws[addr] ? ws[addr].v : XLSX.utils.encode_col(C);
  }
  /* De-duplicate headers */
  for(var i = 0; i < names.length; ++i) if(names.indexOf(names[i]) < i)
    for(var j = 0; j < names.length; ++j) {
      var _name = names[i] + "_" + (j+1);
      if(names.indexOf(_name) > -1) continue;
      names[i] = _name;
    }

  /* Guess column types */
  var types = new Array(range.e.c-range.s.c+1);
  for(C = range.s.c; C<= range.e.c; ++C) {
    var seen = {}, _type = "";
    for(R = range.s.r+1; R<= range.e.r; ++R) seen[(ws[XLSX.utils.encode_cell({c:C,r:R})]||{t:"z"}).t] = true;
    if(seen.s || seen.str) _type = "TEXT";
    else if(seen.n + seen.b + seen.d + seen.e > 1) _type = "TEXT";
    else switch(true) {
      case seen.b:
      case seen.n: _type = "REAL"; break;
      case seen.e: _type = "TEXT"; break;
      case seen.d: _type = "TEXT"; break;
    }
    types[C-range.s.c] = _type || "TEXT";
  }

  /* Create table */
  log_and_exec(db, "DROP TABLE IF EXISTS `" + sname + "`;" );
  log_and_exec(db, "CREATE TABLE `" + sname + "` (" + names.map(function(n, i) { return "`" + n + "` " + (types[i]||"TEXT"); }).join(", ") + ");" );

  /* Insert data */
  for(R = range.s.r+1; R<= range.e.r; ++R) {
    var fields = [], values = [];
    for(var C = range.s.c; C<= range.e.c; ++C) {
      var cell = ws[XLSX.utils.encode_cell({c:C,r:R})];
      if(!cell) continue;
      fields.push("`" + names[C-range.s.c] + "`");
      var val = cell.v;
      switch(types[C-range.s.c]) {
        case 'REAL': if(cell.t == 'b' || typeof val == 'boolean' ) val = +val; break;
        default: val = '"' + val.toString().replace(/"/g, '""') + '"';
      }
      values.push(val);
    }
    if(fields.length > 0) log_and_exec(db, "INSERT INTO `" +sname+ "` (" + fields.join(", ") + ") VALUES (" + values.join(",") + ");");
  }
}
